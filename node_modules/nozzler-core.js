// - gather needed info
// - process communication
// - if end or timeout, go to next
// 
// - spawn child casperjs to process url
// - casper enters the nozzle
// - casper captures the captcha (captchure)
// - casper must hang until captcha solution
// - when solution is done, apply 
// 
// Apparently, you need to hang many processes to make available more than one challenge 
// - QUESTION: How many open sites is it possible to leave waiting at a time?
// - Is it possible to PAUSE and RESUME a session?
// 
// Você precisa separar peças relevantes, e manter o mínimo considerável disponível como um módulo atômico

var getPrice = require('price-btc')(init);
var countTotal = 0;

var nozzleList = require('nozzle-filtered-CLEAN').results;//.slice(350);
var startTime = +new Date;
var totalFunds = 0;

var btcPrice;

var activeProcesses = 0;

function getBalance(btcPrice, url) {
    var balance = require('child_process').spawn('casperjs', ['node_modules/balancer.js', url, btcPrice]);
    
    activeProcesses++;
    
    // if this is not done in 1 minute, fuck off!
    var childTimeout = setTimeout(function () {
        console.log("\n\nKILL: ", url);
        balance.kill('SIGINT');
    }, 90000);
    
    var final = '';
    var defer = {
        then: function (resolve) {
            this.resolve = resolve;
        }
    };
    
    function onBalanceData(data) {
        final += data.toString();
    }
    
    function onBalanceEnd() {
        clearTimeout(childTimeout);
        
        final = final.replace(/Unsafe JavaScript attempt to access frame with URL about:blank from frame with URL .*?\. Domains, protocols and ports must match\./ig, '');

        console.log(">>>", final);
        
        var jsonStart = final.indexOf("{");
        
        if (jsonStart > -1) {
            final = final.substr(jsonStart);
            final = JSON.parse(final.trim());
        } else {
            final = {url:url, error:final};
        }
        
        countTotal++;
        
        defer.resolve(final);
        
        activeProcesses--;
        processNextNozzle();
    }
    
    balance.stdout.on('data', onBalanceData);

    balance.stdout.on('end', onBalanceEnd);
    
    return defer;
}

function throttle(omega) {
    var alpha = +new Date, delta = 0;
    return function throttled() {
        delta = (+new Date - alpha);
        if (delta > 300) {
            alpha = +new Date;
            delta = 0;
            return omega.apply(this,arguments);
        }
    };
}

function processNozzle(link) {
    if (link) {
        getBalance(btcPrice, link).then(processTotal);
    }
}

function processTotal(balance) {
    if (balance.BTCtoUSD && balance.USDtoBRL) {
        var BTCtoUSD = balance.BTCtoUSD;
        var USDtoBRL = balance.USDtoBRL;
        totalFunds += balance.satoshi;
        fundsBTC = totalFunds / 1e8;
        fundsUSD = fundsBTC * BTCtoUSD;
        fundsBRL = fundsUSD * USDtoBRL;

        var total = {
            timestamp: (new Date()).toString(),
            BTCtoUSD: BTCtoUSD,
            USDtoBRL: USDtoBRL,
            satoshi: totalFunds,
            fundsBTC: fundsBTC,
            fundsUSD: parseFloat(fundsUSD.toFixed(2), 10),
            fundsBRL: parseFloat(fundsBRL.toFixed(2), 10)
        };

        console.log(countTotal, (+new Date) - startTime, "TOTAL: ", total);

    } else {
        console.log(countTotal, (+new Date) - startTime, "ERROR: ", balance, "\n\n");
        return;
    }
}

function obfuscateWallet(link) {
    return link.replace('weFVogcxq6K21zWXf1NnFcBCTTcmEYH4LC', Math.random().toString(35).substr(2, 34));
}

function processNextNozzle() {
    var nozzle = nozzleList.shift();
    var link;

    if (nozzle) {
        link = obfuscateWallet(nozzle.link);
        console.log(link);
        processNozzle(link);
    } else {
        if ( ! activeProcesses) {
            nozzleListEnd();
        }
    }
}

function nozzleListEnd() {
    console.log("\n\n -- \n\n");
}

function init(currentBtcPrice) {
    console.log(nozzleList.length);
    
    btcPrice = currentBtcPrice;

    processNextNozzle();
    processNextNozzle();
    processNextNozzle();
    processNextNozzle();
}

